[
  {"title":"裁判文书要素提取的准确性", "time":"2015-03-11", "itemsrc":"https://www.zybuluo.com/hfkun/note/296983", "abstract":"最近在做一个关于文本识别和信息提取的项目，提取内容是浙江裁判文书。文书总数大概是350万，提取的内容包括案件基本信息、人员信息、审理判决信息等。我要做的事情，就是提取出关于人员、组织机构的基本信息。下面主要以人员信息中案件角色的提取为例子进行分析。一份裁判文书中包括的角色主要包括：原告、被告、代理人、代表人等。"},
  {"title":"更有效的缓存方式", "time":"2015-07-19", "itemsrc":"https://www.zybuluo.com/hfkun/note/296985", "abstract":"项目中遇到的问题，我来简单描述一下：数据库是老版本的全文数据库，别说sql语法多奇葩，就连稳定性也让人不放心。新华社新华智讯这个项目的稿件量大概在2w条左右，首页显示的栏目有20个之多。对于这样的数据服务器，要等首页完全加载完，得等上好几秒钟。这里需要花这么久有一个原因是数据库服务器稳定性不给力，在连续执行几条SQL语句，就有可能抛异常，这里得考虑出异常之后重新执行。 "},
  {"title":"Jpa懒加载的折腾记录", "time":"2016-01-03", "itemsrc":"https://www.zybuluo.com/hfkun/note/302029", "abstract":"JPA规范中定义了几种对象关系：one-to-one、one-to-many、many-to-one、many-to-many。 <br/>在这里用many-to-one和one-to-many来分析。根据上面的对象定义代码，当我们查询所有部门时，结果是：除了员工信息以外的其他信息，但是保留了getEmployee()这个方法，当调用getEmployee()方法时，JPA又去查数据库了，并且把结果赋值给employees属性。"},
  {"title":"超时调用与间歇调用", "time":"2016-01-12", "itemsrc":"https://www.zybuluo.com/hfkun/note/310908", "abstract":"一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。"},
  {"title":"MySQL数据库优化总结", "time":"2016-03-12", "itemsrc":"https://www.zybuluo.com/hfkun/note/311416", "abstract":"对于一个以数据为中心的应用，数据库的好坏直接影响到程序的性能，因此数据库性能至关重要。一般来说，要保证数据库的效率，要做好以下四个方面的工作：数据库设计、sql语句优化、数据库参数配置、集群，这个顺序也表现了这四个工作对性能影响的大小"},
  {"title":"各种排序算法的总结和比较", "time":"2016-03-14", "itemsrc":"https://www.zybuluo.com/hfkun/note/312235", "abstract":"快速排序比大部分排序算法都要快。尽管我们可以在某些特殊的情况下写出比快速排序快的算法，但是就通常情况而言，没有比它更快的了。快速排序是递归的，对于内存非常有限的机器来说，它不是一个好的选择。堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。"},
  {"title":"算法题-全排列", "time":"2016-03-14", "itemsrc":"https://www.zybuluo.com/hfkun/note/312266", "abstract":"全排列，给定数组（假设长度5），列出所有组合，5!个组合。/** * * 本算法的设计思路： * 排5个长度，指定前面1个，排后面4个 * 排4个长度，指定前面2个，排后面3个 * ... * * @date 2015年8月7日 */ public class FullList {public static void main(String[] args) { int length = 5; int[] index  = new int[length]; for(int i=0; i<length; i++){  index[i] = i; "},
  {"title":"算法题-整数划分", "time":"2016-03-14", "itemsrc":"https://www.zybuluo.com/hfkun/note/312292", "abstract":"整数划分(欧拉拆分),欲计算5的划分，先得到4的划分   再执行两步  第一步遍历结果行，\"+1\" 第二步遍历结果行，+1 去重即为5的结果  public class OLa { public static void main(String[] args) { int n = 50; Set<ArrayList<Integer>> list = digui(n); System. out.println(list.size()); for(ArrayList<Integer> al:list){ System. out.println(al);} }"},
  {"title":"算法题-丢手帕问题", "time":"2016-03-14", "itemsrc":"https://www.zybuluo.com/hfkun/note/312298", "abstract":"丢手帕问题： 约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，每次干掉第M个，最后剩下一个。例如N=6，M=5，被杀掉的人的序号为5，4，6，2，3。最后剩下1号  void test1(){ int len = 22;      //长度 int begin = 10;    //开始位置 int step = 5;      //步长 int count = len;   //剩余数 int i = 0; int y = begin;"},
  {"title":"算法题-八皇后", "time":"2016-03-14", "itemsrc":"https://www.zybuluo.com/hfkun/note/312300", "abstract":"八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。从头开始遍历所有格子，每填一个格子，都计算一下下一次可用的格子  *如果发现结果列表不满8个，可用的格子却没了，那么回溯到上一步 *如果结果列表满8个，同样回溯到上一步，填另一个可用的格子"},
  {"title":"Javascript作用域和变量申明提升", "time":"2016-04-08", "itemsrc":"https://www.zybuluo.com/hfkun/note/338641", "abstract":"如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。"},
  {"title":"RMI 初识", "time":"2016-09-19", "itemsrc":"https://www.zybuluo.com/hfkun/note/506178", "abstract":"上次遇到一个问题，需要从一个WEB项目A中访问另一个WEB项目B的servlet，用的解决办法是 HttpClient，后来突然想到，如果没有http，java程序之间怎么通讯呢，于是就来了RMI。Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。"},
  {"title":"MySQL 事务隔离级别、乐观锁和悲观锁 新感", "time":"2016-12-24", "itemsrc":"https://www.zybuluo.com/hfkun/note/611662", "abstract":"隔离级别决定了一个session中的事务可能对另一个session的影响、并发session对数据库的操作、一个session中所见数据的一致性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁"},
  {"title":"都是分布式事务惹的祸", "time":"2020-02-29", "itemsrc":"https://www.zybuluo.com/hfkun/note/1671104", "abstract":"因项目业务，需要开发一个贷款进件功能，业务描述：渠道方发送贷款申请，推送申请信息，我们要将申请信息落库，然后推到RocketMQ消息队列，返回渠道方。曾怀疑过是不是Mybatis的问题，最后才发现，是为了实现分布式事务，导致是本地事务还没提交，MQ消息已经发出去了，所以MQ消息消费失败。。。"}

  
]